(defn -head [x ..._] x)
(defn ++ [x] (+ x 1))
(defn $ [f x] ((append x f)))

;; threading
(macro ->> [x 'f ...rest] 
    (if (= '() rest)
        ($ f x)
        (ap ->> (cons ($ f x) rest))))

(assert (= 3
    (->> 2
        ++)))

(assert 
    (->> 2
        ++
        (= 3))) ;; partial application

(assert (= 6
    (->> 2
        ++
        (list ++ 1 2)
        (ap -head)
        (->> 3 ;; nesting
            ++
            ++))))

;; lazy branching
(macro switch [b 'x ...rest]
    (if b 
        (x)
        (ap switch rest)))

(defn err [] (assert 0))

(assert (= 7
    (switch 
        (= -1 0) 'bad
        (= 1 0) (- 3 2)
        (= 2 0) (err)
        (= 0 0) (+ 3 4))))